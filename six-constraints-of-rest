### Six Constraints of REST

**Representational state transfer**, or **REST**, refers to a group of software architecture design constraints that bring about _efficient, reliable,_ and _scalable systems_.

There are six of these constraints and to understand REST, we need to know what they are and why they are exist to establish REST.   Let's break them down, accordingly. 

**Constraint number one**, _client-server architecture_. 

> This constraint ensures proper separation of concerns. 

The _**client** manages user interface concerns_, while _the **server** manages data storage concerns_. 

> In return, we get a highly portable system where one REST service can serve many different clients and interfaces without knowing or caring what those interfaces look like or what they are doing. 

In short, we have **a complete separation between the content and its presentation and interaction.** 
---

**Constraint number two**, _statelessness_. 

_No client context or information_, AKA **state**, can be stored on the server between requests. 
- The client is responsible for keeping track of its own session state and 
- all requests sent from a client must be self-contained and complete. 

**If the client's session state is relevant**, 
- it must be sent along with a request and 

**If the server needs to store that state,** 
- it must pass it on to a database or similar service for a specific time. 

As an example, 

> the server can be asked to pass on an authentication token for a set period of time to allow authenticated requests. 

---

**Constraint number three**, _cacheability_. 

**Cacheing**, as in storing responses for a set period of time, is an intricate part of web architecture and performance optimization. 

> All REST responses must be clearly marked as cacheable or non-cacheable to ensure caching works as expected on the client end. 

This means 

1. caching responses that won't or are unlikely to change, 
2. caching rarely or periodically changed responses for reasonable periods of time, and 
3. blocking caching for constantly changing responses. 
---

**Constraint number four**, _layered system_. 

> The system must be designed so the client can't know and doesn't care whether it's connected directly to the server or to an intermediary like a mirror or a CDN. 

**This ensures scalability and also helps with security.** 
---

**Constraint number five**, _code on demand_. 

Servers are allowed to transfer executable code in the form of client side JavaScript and compiled components to the client to extend and customize functionality. This is a less common use of rest. 
---
 
**Constraint number six**, _uniform interface_, 
- which breaks down into four more constraints, so it's really not a single constraint but just four more constraints. 

A **uniform interface** must _use resource identification in requests_. 

In REST systems on the web, a URI is used to send a request and that URI will specify what resource it is looking for during the request. 

So a URI like authors/john/bio is requesting his bio as a resource. 
**The key here is the resource is the data sitting on the server.** 

What REST returns is a representation of that resource which can have a different format from the server resource. 

So, **while the resource data may be stored as a table in my SQL,** 
- the return representation may be JSON or XML or even HTML. 

Next, _a **uniform interface** must allow resource manipulation through **representations**_. 

> This means once a client has a representation of a resource, it can also modify or delete that resource. 

In other words, 
> the client given the right level of access, can control what's stored on the server. 

Third, a **uniform interface** must issue **_self-descriptive messages_**. 

> This goes for both sending and receiving REST data. 

**Each representation must describe its own data format**. 

> _So if you're receiving JSON, the response message will have its media type set to JSON. Without this information, the data cannot be reliably parsed._

**And fourth and finally**, a **uniform interface** must _use hypermedia as the engine of application state_. 

This is a complicated way of saying once the client has access to a REST resource, 
_it should be able to discover all available resources and methods through the hyperlinks provided._ 

**Request a page resource and along with the page contents,** 
_the return representation should include hyperlinks to all resources and methods available._ 

In other words, the REST service describes its own use with every returned resource. 

**If and only if** a web-based API meets these six constraints, **it can be considered a RESTful API**.
